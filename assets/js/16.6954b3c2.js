(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{341:function(a,t,v){"use strict";v.r(t);var r=v(1),_=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"微服务和云原生"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微服务和云原生"}},[a._v("#")]),a._v(" 微服务和云原生")]),a._v(" "),t("h2",{attrs:{id:"云原生的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#云原生的定义"}},[a._v("#")]),a._v(" 云原生的定义")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://www.cncf.io",target:"_blank",rel:"noopener noreferrer"}},[a._v("CNCF（Cloud Native Computing Foundation）"),t("OutboundLink")],1),a._v("对云原生的定义如下：")]),a._v(" "),t("blockquote",[t("p",[a._v("云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。（Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.）")]),a._v(" "),t("p",[a._v("这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。")]),a._v(" "),t("p",[a._v("云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。")])]),a._v(" "),t("p",[a._v("关键目标：构建和运行可弹性扩展的应用。\n关键技术、架构、理念：容器技术；服务网格、微服务架构；不可变基础设施、声明式 API。")]),a._v(" "),t("h2",{attrs:{id:"架构可弹性扩展的应用-scalable-application-的准则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#架构可弹性扩展的应用-scalable-application-的准则"}},[a._v("#")]),a._v(" 架构可弹性扩展的应用（Scalable Application）的准则")]),a._v(" "),t("ul",[t("li",[a._v("在性能维度上，为了充分利用资源，需要对应用进行更细粒度的划分；")]),a._v(" "),t("li",[a._v("在功能维度上，为了更快速的响应，需要对应用进行更细粒度的划分；")])]),a._v(" "),t("h2",{attrs:{id:"如何构建-build"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何构建-build"}},[a._v("#")]),a._v(" 如何构建（Build）")]),a._v(" "),t("h3",{attrs:{id:"理论基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#理论基础"}},[a._v("#")]),a._v(" 理论基础")]),a._v(" "),t("p",[a._v("构建属于开发范畴。")]),a._v(" "),t("p",[a._v("可使用微服务（Microservices）或服务网格（Service Mesh）架构，而声明式 API 是这两者的设计准则。")]),a._v(" "),t("p",[a._v("微服务和服务网格（也被称为第二代微服务），都是从功能维度，纵向分割系统（相对于横向分层），对业务建模能力要求颇高；声明式 API 对应命令式 API，描述想要的结果，而非具体步骤，是一种开发领域的抽象思维；")]),a._v(" "),t("p",[a._v("相对于传统的整体服务模式，微服务对业务功能的分割是细粒度的，系统也从单体应用转向分布式应用。")]),a._v(" "),t("p",[a._v("性能方面，微服务可以以功能节点为单位，实现横向扩展，更加充分地利用资源；\n功能方面，更细的粒度划分，也使得大规模系统的功能修改、测试、部署，代价更低；")]),a._v(" "),t("p",[a._v("细粒度的功能划分，并单立为功能节点，虽有诸多好处，但也引入了新的技术问题，包括服务治理、服务通信、节点观测、分布式事务等。")]),a._v(" "),t("h3",{attrs:{id:"服务治理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务治理"}},[a._v("#")]),a._v(" 服务治理")]),a._v(" "),t("p",[a._v("微服务架构中，各个服务节点之间需要相互通信（调用），考虑到弹性扩展的要求，需要一个可以动态实现服务发现和注册的特殊节点，且为了规避单点故障风险，这类节点须集群部署，并同样支持弹性扩展。")]),a._v(" "),t("p",[a._v("既然服务治理节点为集群结构，不可避免的要面对一致性（Consistency）与可用性（Availability）的权衡问题，基于不同的角度，各类框架都有自己的选择（CP 或 AP）。")]),a._v(" "),t("p",[a._v("服务治理方面的技术框架包括 Spring Cloud Eureka（Netflix）、Nacos（Alibaba）、Zookeeper，甚至 CoreDNS（直接采用基于 UDP 的 DNS 协议）。")]),a._v(" "),t("h3",{attrs:{id:"服务通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务通信"}},[a._v("#")]),a._v(" 服务通信")]),a._v(" "),t("p",[a._v("微服务架构中的节点需要相互通信，则不可避免的需要通信协议，各个框架在这方面基本上分为两个阵营：基于 TCP 的私有协议、基于 HTTP 的通用协议。")]),a._v(" "),t("p",[a._v("私有协议通常基于 TCP + Protobuf（一种二进制序列化方案，由谷歌发明），如早期的 Apache Dubbo（基本上由阿里维护），优势是可以获得更好的性能，劣势是不具备通用型，网络约束较多。")]),a._v(" "),t("p",[a._v("通用协议通常基于 HTTP（RESTful） + JSON（一种文本化序列化方案），如 Spring Cloud Feign，优势是通用、协议穿透性好，劣势是相较私有协议有一定的性能损耗。")]),a._v(" "),t("p",[a._v("由于 HTTP/2 的发展，像 Dubbo 这样的框架也提供了通用协议的支持（gRPC，基于 HTTP/2 + Protobuf），这或许是将来的发展趋势。")]),a._v(" "),t("h3",{attrs:{id:"节点观测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#节点观测"}},[a._v("#")]),a._v(" 节点观测")]),a._v(" "),t("p",[a._v("用于节点观测的解决方案，通常被称为 APM（Application Performance Management）系统，它的主要任务是日志归集（Logs）、链路追踪（Traces），以及对上述两者的统计和度量（Metrics）。")]),a._v(" "),t("p",[a._v("日志归集方面，通常采用 Elastic Stack（之前称作 ELK Stack），它主要包含四个组件：全文搜索引擎 Elasticsearch（起源于 Apache Lucene）、可视化系统 Kibana、数据处理管道 Logstash、各类数据采集代理 Beats（如用于文件式日志采集的 FileBeats）。")]),a._v(" "),t("p",[a._v("链路追踪方面，主要使用符合 OpenTracing 规范的开源组件，如 Jaeger（CNCF）、SkyWalking（Apache）。链路追踪一般需要在程序中打点，对开发有侵入性，对程序性能有一定影响。")]),a._v(" "),t("p",[a._v("统计度量涵盖日志归集和链路追踪，由各自采用的组件负责。基于对日志的统计分析，可以实现异常的定位和修复；基于链路追踪的度量分析，可以提供各个服务节点的性能指标，作为性能扩展的依据。")]),a._v(" "),t("h3",{attrs:{id:"分布式事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[a._v("#")]),a._v(" 分布式事务")]),a._v(" "),t("p",[a._v("分布式事务一直是分布式系统的一大难题，基于不同的理论基础也发展出了许多解决方案，例如基于同步、长事务的两段式提交（XA），基于异步、短事务的 Saga、TCC（Try-Confirm-Cancel）等。")]),a._v(" "),t("p",[a._v("Java 开发中可使用开源框架 Seata 或 LCN（Lock Control Notify）等。")]),a._v(" "),t("p",[a._v("分布式事务在业务完整性、性能方面存在诸多难题，应谨慎对待，甚至在可行的情况下尽量规避。")]),a._v(" "),t("h3",{attrs:{id:"开源框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开源框架"}},[a._v("#")]),a._v(" 开源框架")]),a._v(" "),t("p",[a._v("技术实践方面，可采用 Spring Cloud（相对于微服务）或 Istio（相对于服务网格）等开源框架。")]),a._v(" "),t("h4",{attrs:{id:"spring-cloud"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud"}},[a._v("#")]),a._v(" Spring Cloud")]),a._v(" "),t("ul",[t("li",[a._v("Spring Cloud 可籍由 Eureka、Nacos、Zookeeper 甚至 CoreDNS 等实现服务治理；")]),a._v(" "),t("li",[a._v("通信方面，有自家的 Spring Cloud Feign，也可整合 Apache Dubbo;")]),a._v(" "),t("li",[a._v("Spring Cloud 还提供了许多其他组件（如 Ribbon），解决节点负载均衡等问题；")])]),a._v(" "),t("h4",{attrs:{id:"istio"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#istio"}},[a._v("#")]),a._v(" Istio")]),a._v(" "),t("p",[a._v("Istio 采用 SideCar 模式，亦相当于基础设施的一部分。")]),a._v(" "),t("p",[a._v("作为基础设施，Istio 内置了服务治理、服务通信的解决方案，以及部分的节点观测解决方案（跟踪、度量、访问日志）；")]),a._v(" "),t("h2",{attrs:{id:"如何运行-run"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何运行-run"}},[a._v("#")]),a._v(" 如何运行（Run）")]),a._v(" "),t("p",[a._v("运行属于运维范畴。")]),a._v(" "),t("p",[a._v("随着软件行业的不断发展和云计算的兴起，运维工作也逐渐发展起来，且愈发重要。开发与运维职责划分越来越细，但相互间的联系也十分紧密，既要各司其职，又要紧密合作，而他们之间最好的“桥梁”，是不可变基础设施。")]),a._v(" "),t("p",[a._v("不可变基础设施对应可变基础设施，在传统的部署过程中，基础设施（即软件及其整个运行环境）是可变的，软件的更新、运行环境的配置，都会改变基础设施，这带来的风险就是，部署结果对于运维人员来说，往往不可预测；不可变基础设置，在部署完成之后即不再改变，这大大提高了部署结果的可控性，支撑这一理念的是以 Docker 为代表的容器技术。")]),a._v(" "),t("p",[a._v("容器技术不但方便了系统的部署，也为弹性扩展提供了便利性。结合容器编排技术（如 Kubernetes），可集中管理、分配硬件资源，并以容器（一个或多个）为调度单位，进行扩展、更新。")]),a._v(" "),t("p",[a._v("运维工作较开发来说较为年轻，因而技术分枝较少，但工作难度和技术要求并不低。")]),a._v(" "),t("h2",{attrs:{id:"一点思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一点思考"}},[a._v("#")]),a._v(" 一点思考")]),a._v(" "),t("h3",{attrs:{id:"关于技术应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于技术应用"}},[a._v("#")]),a._v(" 关于技术应用")]),a._v(" "),t("p",[a._v("毫无疑问，云原生涵盖了一切优秀的大规模系统，或大规模活跃系统的构建及运行解决方案，是一项令人振奋的技术。")]),a._v(" "),t("p",[a._v("但对于技术而言，在实践层面，没有最好的，只有最合适的，通用的最佳标准操作流程（SOP）大都在具体实施阶段，而决策层面更多的需要借助科学的方法论和创造力。")]),a._v(" "),t("p",[a._v("新的技术，除了解决问题之外，无外乎两个目的 Better & Cheaper，更优秀的产品（结果）和更低廉的成本（过程），云原生技术代表了更高的效率（包括过程和结果），但不意味着更低的投资（在项目规模维度上应为对数增长）。")]),a._v(" "),t("h3",{attrs:{id:"关于软件工程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于软件工程"}},[a._v("#")]),a._v(" 关于软件工程")]),a._v(" "),t("p",[a._v("云原生技术的使用，不单影响着设计、开发环节，同样影响着整个软件工程，传统的软件工程模型重视需求，重视开发、测试，对运维关注较少，甚至这也表现在了螺旋迭代的软件工程模型的应用当中，而云原生技术将开发与运维，以及测试紧密的关联在一起（DevOps），且对需求管理和业务建模有着更高的要求。")]),a._v(" "),t("p",[a._v("云原生技术更适用于计划性强，交付节奏稳定的项目，这同样体现了其对高水准的需求管理和业务建模能力的依赖。")]),a._v(" "),t("h3",{attrs:{id:"关于开发语言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于开发语言"}},[a._v("#")]),a._v(" 关于开发语言")]),a._v(" "),t("p",[a._v("Java 是一种高度成熟、稳定，且适用性高的语言，有着空前强大的社区生态，在绝大多数领域，其他语言能做到的，Java 同样也能做到，但显而易见，它并非能在所有领域做到最好。在主流的观点里，Go 语言是更适用于云原生技术的，这种观点不仅因为云原生技术中涉及的 Docker、K8s、Istio 都基于 Go 开发，也因为 Go 语言一些与生俱来的特性。")]),a._v(" "),t("p",[a._v("Java 是一种天生的面向对象的语言，结构严谨、优雅，同样也有着庞大的体系和较高的学习曲线；Go 是一种面向过程的语言，函数是“一等公民”，简单、直接，轻量、快速，但也有着令人诟病的异常处理机制和垃圾回收性能。")]),a._v(" "),t("p",[a._v("在构建阶段，Java 的面向对象特性，使其在架构大型系统方面具有先天优势；Go 的面向过程特性，使其在处理细粒度的业务功能时更简单、快速。")]),a._v(" "),t("p",[a._v("在运行阶段，Java 和 Go 都是跨平台的开发语言，都能做到“一份代码，随处运行”（Write once, run anywhere），Java 靠的是 JVM（Java Virtual Machine），Go 靠的是编译器（原生的 GC，Golang Complier 和第三方的 GCC GC）。由于无需 JVM 层，Go 在多数场景下具有更好的系统开销，但由于编译器的成熟度问题，也存在安全性和可靠性风险（GC 实现不严谨，对 32 位系统、ARM 架构支持较差，GCC GO 虽有良好的目标环境优化，但缺少逃逸检测）。")]),a._v(" "),t("p",[a._v("Java 和 Go 都在健康成长，Java 有了函数试接口，Lambda 表达式中也有着许多对函数友好的语法糖；Go 支持了泛型，在性能、稳定性方面也不断的精进；但始终有些优势是“先天的”。")])])}),[],!1,null,null,null);t.default=_.exports}}]);